import { ResetGlobalDisplayNames } from '@idl/parsing/index';
import { LoadTask } from '@idl/schemas/tasks';
import { GetExtensionPath } from '@idl/shared';
import { GlobalTokens } from '@idl/types/core';
import { TaskToGlobalToken } from '@idl/types/tasks';

describe(`[auto generated] Correctly parse task file`, () => {
  it(`[auto generated] envi`, async () => {
    // specify reference filepath
    const filepath = GetExtensionPath(
      'idl/test/task-parsing/PointCloudFeatureExtraction.task'
    );

    // reset global display names
    ResetGlobalDisplayNames();

    // load our task
    const task = await LoadTask(filepath);

    // define expected local variables
    const expected: GlobalTokens = [
      {
        type: 's',
        name: 'envipointcloudfeatureextractiontask',
        pos: [0, 0, 0],
        meta: {
          display: 'ENVIPointCloudFeatureExtractionTask',
          source: 'user',
          docs: 'This task extracts features from point cloud data (buildings, trees, powerlines) and can produce a DEM, DSM, orthophoto, TIN, classified point cloud and 3D viewer database.',
          private: false,
          inherits: ['envitask'],
          docsLookup: {},
          props: {
            input_point_cloud: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'input_point_cloud',
              docs: 'Specify an ENVIPointCloud object on which to perform feature extraction.',
              type: [
                {
                  name: 'ENVIPointCloudBase',
                  display: 'ENVIPointCloudBase',
                  args: [],
                  meta: {},
                },
              ],
            },
            spatialref: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'spatialref',
              docs: 'An ENVIPointCloudSpatialRef object that specifies the desired coordinate system of the generated products. If this property is not set, the default of UTM WGS84 will be used.',
              type: [
                {
                  name: 'ENVIPointCloudSpatialRef',
                  display: 'ENVIPointCloudSpatialRef',
                  args: [],
                  meta: {},
                },
              ],
            },
            general_clip_min_height: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'general_clip_min_height',
              docs: 'The minimum height extent of the source dataset in which processing will occur.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            general_clip_max_height: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'general_clip_max_height',
              docs: 'The maximum height extent of the source dataset in which processing will occur.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            general_max_points_density: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'general_max_points_density',
              docs: "This parameter limits the processed number of points. The limit is applied by taking only some of the points per block of data; a single block's dimensions are 32x32 meters. Limiting the density shortens the processing time of the buildings and power line detection algorithms.",
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            general_points_density_units: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'general_points_density_units',
              docs: 'The units of the maximum points density. 0: points per square meter, 1: ground sample distance in meters.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            number_of_cores: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'number_of_cores',
              docs: 'The number of cores used for product processing. The default value is zero, which indicates that all available cores will be used for processing. If a value larger than the number of available cores is specified, then the maximum number of available cores will be used.',
              type: [{ name: 'ULong', display: 'ULong', args: [], meta: {} }],
            },
            save_parameters: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'save_parameters',
              docs: 'Sets whether to save the parameters with the data (in the project) when Execute() is called. If the parameters are saved the next time the data is opened and set in INPUT_POINT_CLOUD, calling ENVITask::Validate() or ENVITask::Execute() will restore the saved parameters (but will not overwrite any parameters set on the ENVITask). 0: Do not save. 1: Save.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            products_location: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'products_location',
              docs: 'The name of the output folder to which the associated product files will be written. This location is a subfolder of the main project folder.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            buildings_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_generate',
              docs: '0: Do not generate. 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            buildings_use_box_models: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_use_box_models',
              docs: '0: Do not use box models. 1: Use box models. This stops the algorithm from dividing buildings into sub-surfaces, and leaves them as flat roof bounding contours. The classification stays the same, but only one contour is generated at the requested height with the options set using the BUILDINGS_BOX_MODELS_TYPE parameter.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            buildings_box_models_type: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_box_models_type',
              docs: 'Sets the roof contour height. 0: Height at Average Roof. The roof contour is set at the average height of the roof. 1: Height at Bottom Roof. The roof contour is set at the lowest point of the roof. 2: Height at Top Roof. The roof contour is set at the highest point of the roof.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            buildings_minimum_area: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_minimum_area',
              docs: 'Surfaces with an area smaller than this are filtered out from the building list. Units: square meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            buildings_near_ground_filter_width: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_near_ground_filter_width',
              docs: 'After filtering by BUILDINGS_MINIMUM_AREA, objects less than 5 meters above the ground with a side smaller than this filter width (default 300 centimeters) are not classified as buildings. This is useful for preventing buses, trucks, train cars, and so forth from being classified as buildings. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            buildings_plane_surface_tolerance: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_plane_surface_tolerance',
              docs: 'This parameter is the allowed vertical tolerance for searching for the surface in the neighboring points. Range: greater than or equal to 15.0 and less than or equal to 60.0. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            buildings_points_in_range: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_points_in_range',
              docs: 'Normally this should be left at 0, which is the same as Auto in the user interface. However, if you have low density data (1 point per m2 or lower), large buildings such as hangars or warehouses may not be classified as buildings. Increasing this value to 1.2 or 1.4 will help detect them, but runs the risk of also identifying trees as buildings. Range: greater than or equal to 0.5 and less than or equal to 1.4. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            buildings_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_format',
              docs: 'A string value that specifies the file format to write buildings to: dxf, shp, dae_1.4, dae_1.5, kml or kmz.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            buildings_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'buildings_uri',
              docs: 'A string value specifying the filename for the buildings product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_contours_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_contours_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_contours_lines_spacing: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_contours_lines_spacing',
              docs: 'This is the vertical spacing between height contour lines. This step is done after the DEM grid is generated; therefore, it does not affect the DEM grid generation. Range: greater than or equal to 50 and less than or equal to 1000. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_contours_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_contours_format',
              docs: 'A string value that specifies the file format to write DEM contours to: dxf or shp.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_contours_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_contours_uri',
              docs: 'A string value specifying the filename for the DEM contours product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_filter_database_edges: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_filter_database_edges',
              docs: 'In some types of terrain, for example forested areas with trees at the edge of the dataset, the algorithms of the DEM grid generation do not detect the edges of the database well. 0: Process the edge of the database. 1: Do not process the edge of the database. The points that lie within an area up to 16 meters from the edges of the dataset are classified as unprocessed.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_grid_resolution: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_grid_resolution',
              docs: 'The grid resolution range allows selection of 50 to 1000 centimeters per pixel. Internally a 50 cm or 100 cm grid resolution is used and sub-sampled to 200-1000 cm if selected. The 50 cm grid tunes the DEM extraction algorithms to be more sensitive at some points, and requires higher density data. If the project density is lower than 4 points / m2, selecting the 50 cm grid will not result in better resolution of the DEM and the amount of time to create the DEM will increase. Range: Greater than or equal to 50 and less than or equal to 1000. Units: centimeters. ',
              type: [{ name: 'ULong', display: 'ULong', args: [], meta: {} }],
            },
            dem_constant_height_offset: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_constant_height_offset',
              docs: 'In noisy datasets the elevation of the DEM may be slightly offset due to inaccurate points above and below the ground. If this happens you can shift the terrain grid up or down. A positive number will move the DEM up, and a negative number will move the DEM down.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_near_terrain_classification: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_near_terrain_classification',
              docs: 'When set at 50 (the default value), a point is considered to be a terrain classified point if it is within 50cm of the grid. You can select to have a near terrain classification between 5cm and 50cm. As an example, if this parameter is set to 20cm, points with a distance of 0 to 20cm from the grid are classified as terrain points, and points with a distance of 20 to 50cm are classified as near terrain points. Classifying points as near terrain is useful to catch low objects that are neither part of the terrain, nor are they buildings, trees or powerlines. For example: low vegetation, cars, buses, etc. could all be classified as near terrain objects. Range: greater than or equal to 15 and less than or equal to 50. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_variable_sensitivity_algorithm: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_variable_sensitivity_algorithm',
              docs: '0: Disabled 1: Enable variable sensitivity algorithm. This algorithm works best in low-density forest areas and areas with large gaps between points. However, this algorithm has difficulty with identifying large buildings.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_sensitivity: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_sensitivity',
              docs: 'Use when DEM_VARIABLE_SENSITIVITY_ALGORITHM is enabled. The higher the sensitivity, the better it works with higher frequency terrain, but also it tends to extract buildings from points that should be identified as terrain. Valid range is 1 (low) to 300 (high).',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_filter_lower_points: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_filter_lower_points',
              docs: '0 : Do Not Filter. Disables filtering of points that are lower than the terrain. 3 : Urban Area Filtering. The area is divided to the grid resolution. For each cell in the grid, the list of points is put into a histogram and examined. Points are sorted by height, and the median point and standard deviation are found. Points that are below a multiplier of the standard deviation from the median are filtered out. If the standard deviation is too large, gaps are also counted in the histogram for better filtering. Urban areas have more false points that needed to be filtered. If you specify rural filtering in an urban area, some of the false points will not be detected. 10: Rural Area Filtering. Processing is done as it is in Urban Area Filtering. If you specify urban filtering in a rural area, the filtering may be too aggressive, and some good terrain points in forest areas may be filtered out resulting in bumps under trees.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_format',
              docs: "A string value that specifies the file format to write the DEM to: 'img' - Erdas Elevation (Erdas Imagine IMG format with elevation data), 'surfer_ascii' - Surfer ASCII Grid, 'surfer_v6' - Surfer Binary Grid v6, 'usgs_ascii' - USGS ASCII DEM format, 'xyz_ascii' - XYZ ASCII Grid file, 'arcinfo_ascii' - Arc Info ASCII Grid format, 'geotiff' - GeoTIFF, 'envi' - ENVI format.",
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_uri',
              docs: 'A string value specifying the filename for the DEM product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_tin_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_tin_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dem_tin_max_error: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_tin_max_error',
              docs: 'The maximum permitted vertical distance between a triangle and the actual terrain. This distance between the TIN and the actual terrain introduces errors into the TIN mesh. Reducing the Maximum Error value will result in a more accurate TIN at the expense of increased triangle count. A combination of this value and DEM_TIN_MAX_POLYGON_DENSITY will affect the TIN representation of the ground. TIN production does not affect the DEM grid production algorithm. The TIN production uses only the points classified as terrain. Reducing the value of the Near Terrain Classification parameter results in reducing the number of points that are classified as terrain, thereby reducing both the time for TIN generation and the size of the TIN generated. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_tin_max_polygon_density: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_tin_max_polygon_density',
              docs: 'When producing TIN, this is the maximum number of triangles that will be produced in a 100 x 100 meter area. It may not be possible to achieve the terrain TIN maximum error if this polygon density parameter is set too low.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            dem_tin_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_tin_format',
              docs: 'A string value that specifies the file format to write the TIN to: dxf or shp.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dem_tin_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dem_tin_uri',
              docs: 'A string value specifying the filename for the DEM TIN product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dsm_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dsm_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dsm_use_powerlines_points: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dsm_use_powerlines_points',
              docs: 'Specifies whether power lines and cables will be part of the DSM. Valid values are 0: Do not include, 1: Include.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            dsm_grid_resolution: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dsm_grid_resolution',
              docs: 'This setting specifies the resolution of the DSM grid. Range: Greater than or equal to 5 and less than or equal to 1000. Units: centimeters.',
              type: [{ name: 'ULong', display: 'ULong', args: [], meta: {} }],
            },
            dsm_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dsm_format',
              docs: "A string value that specifies the file format to write the DSM to: 'img' - Erdas Elevation (Erdas Imagine IMG format with elevation data), 'surfer_ascii' - Surfer ASCII Grid, 'surfer_v6' - Surfer Binary Grid v6, 'usgs_ascii' - USGS ASCII DEM format, 'xyz_ascii' - XYZ ASCII Grid file, 'arcinfo_ascii' - Arc Info ASCII Grid format, 'geotiff' - GeoTIFF, 'envi' - ENVI format.",
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            dsm_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'dsm_uri',
              docs: 'A string value specifying the filename for the DSM product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            filtered_pointcloud_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'filtered_pointcloud_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            filtered_pointcloud_separate_by_class: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'filtered_pointcloud_separate_by_class',
              docs: 'Specifies whether to separate the generated point cloud datasets, each containing data from an individual class.. 0: Do not separate, 1: Separate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            filtered_pointcloud_size_limit: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'filtered_pointcloud_size_limit',
              docs: 'Set this to limit the size (Kb) of each of the generated point cloud files. If the value specified is less than 10000 (10MB), a value of 10000 will be used.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            filtered_pointcloud_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'filtered_pointcloud_format',
              docs: 'A string value that specifies the file format to write the pointclouds to: txt, las or bin.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            filtered_pointcloud_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'filtered_pointcloud_uri',
              docs: 'A string value specifying the base file name for the filtered point cloud product. This name can have the following formats: base_filename_unclassified_000.las or base_filename_product_000.las (ex. pc_trees_000.las).',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            orthophoto_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            orthophoto_intensity_range_min: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_intensity_range_min',
              docs: 'All points with intensity lower than this value appear black. Use the default value (0) unless you see that the file is all or mostly white, in which case increase the value.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            orthophoto_intensity_range_max: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_intensity_range_max',
              docs: 'All points with intensity higher than this value appear white. Use the default value (255) unless you see that the file is all or mostly black, in which case decrease the value.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            orthophoto_resolution: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_resolution',
              docs: 'This parameter specifies the resolution of the generated orthophoto. Range: greater than or equal to 25 and less than or equal to 800. Units: centimeters.',
              type: [{ name: 'ULong', display: 'ULong', args: [], meta: {} }],
            },
            orthophoto_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_format',
              docs: 'A string value that specifies the file format to write the orthophoto to: geotiff, jpg, png, img, bmp, or envi.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            orthophoto_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'orthophoto_uri',
              docs: 'A string specifying the filename for the orthophoto product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            powerlines_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerlines_filter_by_min_joined_length: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_filter_by_min_joined_length',
              docs: '0: Do not filter powerlines by minimum joined length. 1: Filter powerlines by minimum joined length.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerlines_filter_trees_below_powerlines: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_filter_trees_below_powerlines',
              docs: '0: Do not filter trees below powerlines. 1: Filter trees below powerlines. Sometimes trees considerably below powerlines may be incorrectly extended up to the powerlines. Filtering trees below powerlines attempts to vertically separate tree and powerline points, but this can sometimes incorrectly remove the entire tree.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerlines_search_wide: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_search_wide',
              docs: '0: Do not get one line for triple conductors attached together in transmission lines. 1: Get one line for triple conductors attached together in transmission lines. Do not use this parameter and POWERLINES_SEARCH_LOWKV together.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerlines_search_lowkv: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_search_lowkv',
              docs: '0: Do not search for low kilo volt power lines that are close to each other. 1: Search for low kilo volt power lines that are close to each other. Do not use this parameter and POWERLINES_SEARCH_WIDE together.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerlines_min_height: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_min_height',
              docs: 'The minimum height of points from the ground at which to detect power lines. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerlines_min_joined_length: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_min_joined_length',
              docs: 'The Min. length threshold for joined power lines. Joined power lines shorter than this value will not be detected. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerlines_min_length: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_min_length',
              docs: 'The minimum length threshold for power lines. Power lines shorter than this value will not be detected. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerlines_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_format',
              docs: 'A string value that specifies the file format to write the powerlines to: dxf or shp.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            powerlines_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerlines_uri',
              docs: 'The filename for the power lines product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            powerpoles_detect: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_detect',
              docs: '0: Do not generate power pole output. 1: Process power poles by searching, or by using the imported power poles locations reference list. Power poles are searched for by looking for attachment points where two power lines have a shared point. After identifying these shared points, the algorithm searches for a cluster of points with a shared angle range of lines extending from the shared points.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerpoles_search_additional: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_search_additional',
              docs: 'The power poles can be imported from a file using the POWERPOLES_LOCATION_FILE property. If a list of points was imported, set this to 1 to enable a search of additional power poles. If not enabled, only the imported power poles will be processed.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            powerpoles_class_extend_top: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_class_extend_top',
              docs: 'See POWERPOLES_CLASS_RADIUS_LOW. The classification of the top part of the power pole is done by the width of the power poles arms. If a wider radius is needed, use this parameter to extend it. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerpoles_class_radius_low: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_class_radius_low',
              docs: 'If the radius of the power pole is known, set the parameter to the known radius of the base (lower half). For large pylons if this parameter is not increased high enough not all of the points on the pylon will be classified as power pole. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerpoles_extend_wires_distance: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_extend_wires_distance',
              docs: 'Sets the maximum gap to be corrected. Capability is provided to bridge gaps in the line from the end of the detected line to the next power pole. Units: meters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerpoles_max_radius_top: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_max_radius_top',
              docs: "A float value indicating the maximum radius of the pole's arm. Units: meters.",
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            powerpoles_location_file: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'powerpoles_location_file',
              docs: 'A string containing the file name of the power pole locations file to import.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            trees_generate: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_generate',
              docs: '0: Do not generate, 1: Generate.',
              type: [{ name: 'Byte', display: 'Byte', args: [], meta: {} }],
            },
            trees_min_height: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_min_height',
              docs: 'The minimum height of trees in the project. Points having characteristic trees dispersal will be classified as trees. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            trees_max_height: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_max_height',
              docs: 'The maximum height of trees in the project. Higher points will not be classified as trees. This avoids items such as cranes being classified as trees. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            trees_min_radius: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_min_radius',
              docs: 'The minimum radius of trees in the project. This avoids items such as lampposts being classified as trees. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            trees_max_radius: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_max_radius',
              docs: 'The maximum radius of trees in the project. Units: centimeters.',
              type: [{ name: 'Float', display: 'Float', args: [], meta: {} }],
            },
            trees_format: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_format',
              docs: 'A string value that specifies the file format to write the trees to: csv or shp.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            trees_uri: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'in',
              private: false,
              display: 'trees_uri',
              docs: 'The filename for the trees product.',
              type: [{ name: 'String', display: 'String', args: [], meta: {} }],
            },
            output_products_info: {
              source: 'user',
              code: true,
              pos: [0, 0, 0],
              direction: 'out',
              private: false,
              display: 'output_products_info',
              docs: 'An object reference to an instance of enviPointCloudProductsInfo containing paths to all the generated files.',
              type: [
                {
                  name: 'ENVIPointCloudProductsInfo',
                  display: 'ENVIPointCloudProductsInfo',
                  args: [],
                  meta: {},
                },
              ],
            },
          },
        },
      },
      {
        type: 'f',
        name: 'envipointcloudfeatureextractiontask',
        pos: [0, 0, 0],
        meta: {
          display: 'ENVIPointCloudFeatureExtractionTask',
          source: 'user',
          docs: 'This task extracts features from point cloud data (buildings, trees, powerlines) and can produce a DEM, DSM, orthophoto, TIN, classified point cloud and 3D viewer database.',
          private: false,
          returns: [
            {
              name: 'envipointcloudfeatureextractiontask',
              display: 'ENVITask<pointcloudfeatureextraction>',
              args: [
                [
                  {
                    name: 'pointcloudfeatureextraction',
                    display: 'pointcloudfeatureextraction',
                    args: [],
                    meta: {},
                  },
                ],
              ],
              meta: {},
            },
          ],
          args: {},
          kws: {},
          docsLookup: {},
          struct: [],
        },
      },
    ];

    // verify results
    expect(expected).toEqual(TaskToGlobalToken(task));
  });
});
